<!-- ---
lab:
    title: 'Exercise - Resolve GitHub secret scanning alerts using GitHub Copilot'
    description: 'Learn  how to view and interpret Alerts on the repository Security tab, and how to use Copilot’s Chat modes (Ask and Agent) to remediate problems.'
--- -->

# GitHub Copilot を使用して GitHub シークレット スキャンのアラートを解決する

GitHub シークレット スキャンは、コード リポジトリ内での機密情報 (API キー、パスワード、その他のシークレットなど) の露出を検出および防止するように設計されたセキュリティ機能です。 シークレットが検出されると、GitHub によってアラートが生成され、リポジトリ管理者と保守管理者は潜在的なセキュリティ リスクについて通知を受け取ります。

この演習では、GitHub Copilot を使用して、eコマース アプリケーションのコード リポジトリ内の機密情報に関連した GitHub シークレット スキャン アラートを分析して解決します。

この演習の所要時間は約 **40** 分です。

> **重要**:この演習を完了するには、自分の GitHub アカウントと GitHub Copilot サブスクリプションを用意する必要があります。 GitHub アカウントをお持ちでない場合は、無料の個人用アカウントに<a href="https://github.com/" target="_blank">サインアップ</a>し、GitHub Copilot Free プランを使用して演習を完了できます。 ラボ環境内から GitHub Copilot Pro、GitHub Copilot Pro+、GitHub Copilot Business、または GitHub Copilot Enterprise サブスクリプションにアクセスできる場合は、既存の GitHub Copilot サブスクリプションを使用してこの演習を完了できます。

## 開始する前に

ラボ環境には次のリソースが必要です。Git 2.48 以降、.NET SDK 9.0 以降、C# 開発キット拡張機能をインストールした Visual Studio Code、GitHub Copilot が有効になっている GitHub アカウントへのアクセス。

この演習のラボ環境としてローカル PC を使用している場合:

- ローカル PC をラボ環境として構成する方法については、ブラウザーで次のリンクを開いてください。<a href="https://go.microsoft.com/fwlink/?linkid=2320147" target="_blank">ラボ環境のリソースを構成する</a>。

- Visual Studio Code で GitHub Copilot サブスクリプションを有効にする方法については、ブラウザーで次のリンクを開きます: <a href="https://go.microsoft.com/fwlink/?linkid=2320158" target="_blank">Visual Studio Code で GitHub Copilot を有効にする</a>。

この演習に、ホストされたラボ環境をお使いの場合:

- Visual Studio Code で GitHub Copilot サブスクリプションを有効にする方法については、ブラウザーのサイト ナビゲーション バーに次の URL を貼り付けてください: <a href="https://go.microsoft.com/fwlink/?linkid=2320158" target="_blank">Visual Studio Code で GitHub Copilot を有効にする</a>。

- パッケージのダウンロードと復元のソースとして公式の NuGet.org リポジトリを使用するように .NET SDK を確実に構成するには、次の手順を実行します。

    コマンド ターミナルを開き、次のコマンドを実行します。

    ```bash

    dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org

    ```

- 自分の名前と電子メール アドレスを使用するように Git を確実に構成するには、次の手順を実行します。

    次のコマンドを自分の情報で更新し、コマンドを実行します。

    ```bash

    git config --global user.name "Julie Miller"

    ```

    ```bash

    git config --global user.email julie.miller@example.com

    ```

## 演習のシナリオ

あなたは、コンサルティング会社で働くソフトウェア開発者です。 あなたの顧客は、GitHub リポジトリのシークレット スキャン アラートを解決するのに支援を必要としています。 すべてのアラートに確実に対処してそれを解決する必要があります。 開発環境として Visual Studio Code を使用し、開発タスクを支援するために GitHub Copilot を使用します。 あなたには次のレガシ アプリが割り当てられています。

- ContosoOrderProcessor: 顧客の検証、支払い処理、メール通知、データベース操作を含む、従来の eコマース注文処理ワークフロー。 このコードには、一般的なセキュリティの脆弱性を示す (意図的に) 露出されたシークレットが含まれています: 資格情報が埋め込まれたハードコーディングされたデータベース接続文字列、支払いプロバイダーの API キー (Stripe、PayPal)、メール サービス資格情報 (SendGrid)、クラウド インフラストラクチャ アクセス キー (AWS、Azure Storage)。

この演習には、次のタスクが含まれています。

1. ContosoOrderProcessor リポジトリをインポートします。
1. GitHub でセキュリティ アラートを確認します。
1. Visual Studio Code でプロジェクトを開きます。
1. Copilot 質問モードを使用して問題を分析します。
1. コードを修正するには、Copilot エージェント モードを使用します。
1. 変更をコミットしてプッシュし、アラートを確認します。
1. プッシュ保護を有効にしてテストします。

### ContosoOrderProcessor リポジトリをインポートする

GitHub Importer を使用すると、独自の GitHub アカウントに既存のリポジトリのコピーを作成し、インポートされたコピーを完全に制御できます。

このタスクでは、ContosoOrderProcessor リポジトリをインポートします。

そのためには、以下の手順を実行してください。

1. ブラウザー ウィンドウを開いて GitHub.com に移動します。

1. GitHub アカウントにサインインし、[リポジトリ] タブを開きます。

    右上隅にあるプロファイル アイコンをクリックし、**[リポジトリ]** を選択して、[リポジトリ] タブを開きます。

1. [リポジトリ] タブで、**[新規]** ボタンを選択します。

1. **[新しいリポジトリの作成]** セクションで、**[リポジトリのインポート]** を選択します。

    **[プロジェクトを GitHub にインポートする]** ページが表示されます。

1. [プロジェクトを GitHub にインポートする] ページの **[ソース リポジトリの詳細]** で、ソース リポジトリの次の URL を入力します。

    ```plaintext
    https://github.com/MicrosoftLearning/resolve-github-security-alerts-lab-project
    ```

1. **[新しいリポジトリの詳細]** セクションの **[所有者]** ドロップダウンで、GitHub ユーザー名を選択します。

1. **[リポジトリ名]** フィールドに「**ResolveGitHubSecurityAlerts**」と入力し、**[インポートの開始]** を選択します。

    GitHub により、ContosoOrderProcessor プロジェクト ファイルを含む新しいリポジトリがアカウントに作成されます。

1. インポート プロセスが完了するまで待ってから、新しいリポジトリを開きます。

    > **注**:リポジトリのインポートには 1 から 2 分かかる場合があります。

### GitHub でシークレット スキャンを有効にしてセキュリティ アラートを確認する

GitHub のシークレット スキャン機能は、トークン、パスワード、その他のシークレットが誤ってリポジトリにコミットされたときに検出してアラートを生成します。 コードを修正する前に、シークレット スキャンを有効にし、セキュリティ アラートを確認して、コードベースに存在する脆弱性を把握する必要があります。

このタスクでは、リポジトリのシークレット スキャンを有効にして、生成されたセキュリティ アラートを確認します。

そのためには、以下の手順を実行してください。

1. ブラウザー ウィンドウを開き、GitHub.com に移動し、GitHub アカウントにサインインしていることを確認します。

1. **ResolveGitHubSecurityAlerts** リポジトリを開きます。

    右上隅にあるプロファイル アイコンを選択し、**[ご使用のリポジトリ]** を選択して、**ResolveGitHubSecurityAlerts** を選択することで、リポジトリに移動できます。

1. リポジトリの設定にアクセスするには、**[設定]** タブを選択します。

    リポジトリの GitHub ページで、[セキュリティ] タブ ([コード]、[issue]、[pull request] などの横にある) を選択します。

1. 左側のサイドバーから **[Code security and analysis] (コードのセキュリティと分析)** を選択します。

    コードのセキュリティと分析ページには、リポジトリに対して有効にできるさまざまなセキュリティ機能が表示されます。

1. **[シークレット スキャン]** セクションで、シークレット スキャンが現在無効になっていることに注意してください。

    > **注**:パブリック リポジトリでは、シークレット スキャンが既定で有効になっています。 プライベート リポジトリでは、シークレット スキャンを手動で有効にする必要があります。

1. シークレット スキャンを有効にするには、**シークレット スキャン**機能に対して **[有効にする]** を選択します。

    しばらくすると、ページが更新され、有効な状態が表示されます。

1. **[プッシュ保護]** セクションで、プッシュ保護が現在無効になっていることに注意してください。

    プッシュ保護を使用すると、共同作成者は、サポートされているシークレットを含むコミットをプッシュできなくなります。 この演習の後半でプッシュ保護を有効にして、動作をテストします。

1. リポジトリのセキュリティ アラートを表示するには、ページの上部にある **[セキュリティ]** タブを選択します。

    [セキュリティ] タブには、セキュリティ アドバイザリ、Dependabot アラート、コード スキャン アラート、シークレット スキャン アラートなど、リポジトリのセキュリティの概要が表示されます。

1. **[脆弱性アラート]** セクションで、**[シークレット スキャン]** を選択します。

    シークレット スキャンのアラート ページには、リポジトリで検出されたすべてのシークレット スキャン アラートの一覧が表示されます。 各アラートには、シークレットの種類、シークレットが見つかったファイルと行番号、アラートの状態 (オープン、解決済み、または無視) に関する情報が含まれます。

1. 少し時間を取って、シークレット スキャンのアラート ページを確認します。

    "オープン" 状態の複数のアラートが表示されます。 アラートはシークレットの種類別にグループ化され、次のものが含まれます。

    - AWS 認証情報 (AWS アクセス キー ID と AWS シークレット アクセス キー)
    - Azure Storage アカウント キー
    - Stripe API キー
    - PayPal OAuth クライアント ID とシークレット
    - SendGrid API キー
    - Azure SQL 接続文字列

    > **注**:GitHub のシークレット スキャン機能は、パターン マッチングを使用してコードベース内のシークレットを検出します。 表示されるアラートは、トレーニング目的で ContosoOrderProcessor アプリケーションに意図的に含められたシークレットに基づいています。

1. 特定のアラートに関する詳細を表示するために、**[Azure SQL 接続文字列]** のアラートを選択します。

    アラートの詳細ページに、シークレットに関する次のような詳細情報が表示されます。

    - シークレットが見つかったファイル パスと行番号 (Services/DatabaseService.cs、9 行目)
    - コンテキスト内のシークレットを示すコード スニペット
    - シークレットが混入したコミット
    - アラートを解決または無視するオプション

1. 少し時間を取って、アラートに示されたコード スニペットを確認します。

    接続文字列に、データベース サーバー アドレス、データベース名、ユーザー ID、パスワードが含まれていることに注意してください。 リポジトリにアクセスできるすべてのユーザーがこれらの資格情報を見ることができ、データベースにアクセスする可能性があるため、これは重大なセキュリティの脆弱性です。

1. シークレット スキャンのアラート ページに戻ります。

1. **[Stripe API キー]** のアラートを選択し、詳細を確認します。

    このアラートは、PaymentService.cs ファイル (8 行目) を指し、Stripe のライブ API キーを示していることに注意してください。 ライブの支払い API キーを露出させることは、承認されていない料金や機密性の高い支払いデータへのアクセスを許可することになる可能性があるため、重大なセキュリティ リスクです。

1. シークレット スキャンのアラート ページに戻り、少し時間を取って他のアラートを確認します。

    アラートを確認するときは、次のことに注意してください。

    - 各アラートで、シークレットが見つかった特定のファイルと行番号が識別されています
    - アラートは、データベース資格情報、支払い API キー、メール サービス資格情報、クラウド ストレージ資格情報など、複数のカテゴリのシークレットに対応しています
    - 現在、すべてのアラートは "オープン" 状態であり、対処する必要があることを示しています
    - アラートは既知のシークレット形式のパターン マッチングに基づいて生成されました

1. 作業に優先順位を付けるために、最も重要なアラートをメモしておきます。

    - **Azure SQL 接続文字列** (Services/DatabaseService.cs) - データベース資格情報が含まれています
    - **Stripe API キー** (Services/PaymentService.cs) - 支払い処理の資格情報
    - **AWS 資格情報** (Configuration/AppConfig.cs) - クラウド インフラストラクチャへのアクセス
    - **SendGrid API キー** (Services/EmailService.cs) - メール サービスの資格情報

    これらの重要なシークレットは、運用サービスと機密データへの直接アクセスを提供するため、最も高いリスクを表します。 以下のタスクでは、GitHub Copilot を使用してこれらのシークレットを修復することに重点を置きます。

### プロジェクトをクローンして Visual Studio Code で開く

ContosoOrderProcessor アプリケーションは、eコマース注文処理ワークフローをシミュレートする C# コンソール アプリケーションです。 Visual Studio Code を使用して、このアプリケーションの構造と動作を確認できます。

このタスクでは、リポジトリをローカル開発環境にクローンし、Visual Studio Code でプロジェクトを開きます。

そのためには、以下の手順を実行してください。

1. リポジトリのルート ページ ([コード] タブ) に戻ります。

1. ResolveGitHubSecurityAlerts リポジトリをローカル開発環境にクローンします。

    まだ行っていない場合は、Git クライアントまたはコマンド ラインを使用します。

    ```bash
    git clone https://github.com/<your-account>/ResolveGitHubSecurityAlerts.git
    ```

    `<your-account>` は、ご自身の GitHub ユーザー名に置き換えます。

1. クローンしたリポジトリを Visual Studio Code で開きます。

    最新バージョンの Visual Studio Code を使用していること、および GitHub Copilot と GitHub Copilot Chat の各拡張機能がインストールされ、有効になっていることを確認します。

1. エクスプローラー ビューでプロジェクト構造を確認します。

    ContosoOrderProcessor アプリケーションは、次の主要なフォルダーを含むシンプルな階層構造のアーキテクチャに従っています。

    - **Configuration**:アプリケーション全体の構成定数を格納した AppConfig.cs ファイル (露出しているシークレットを含む) が含まれています
    - **モデル**:Customer.cs および Order.cs モデル クラスが含まれています
    - **セキュリティ**: セキュリティ検証ロジックが記述された SecurityValidator.cs ファイルが含まれています
    - **[サービス]**: データベース アクセス、メール送信、支払い処理用のサービス クラス (DatabaseService.cs、EmailService.cs、PaymentService.cs) が含まれています
    - **Program.cs**注文処理ワークフローを示すメイン エントリ ポイント

1. アプリケーションの現在の動作を確認するには、アプリケーションをビルドして実行します。

    アプリケーションを実行するには、Visual Studio Code で統合ターミナルを開き ([ターミナル] > [新しいターミナル])、次のコマンドを実行します。

    ```bash
    dotnet build
    dotnet run --project ContosoOrderProcessor
    ```

    アプリケーションは、注文の作成から支払い処理、メール通知、データベース ストレージまでのワークフローを示す注文処理シミュレーションを実行します。 コンソール出力に詳細なログ情報が表示されます。

1. 時間を取ってコンソール出力を確認します。

    アプリケーションは、構成の詳細と処理手順を含む注文処理ワークフロー全体を表示します。 アプリケーション全体でシークレットがどのように使用されているかを示すログ メッセージに注意してください。 たとえば、接続文字列、API キー、その他の機密情報がコンソールに記録されていることがわかります。

1. **OriginalConsoleOutput.txt** という名前のファイルをプロジェクトのルートに追加します。

    エクスプローラー ビューでファイルを右クリックし、**[新しいファイル]** を選択し、**OriginalConsoleOutput.txt** と名前を付けて、ファイルを作成できます。

1. コンソール出力を **OriginalConsoleOutput.txt** ファイルにコピーします。

    元のコンソール出力とシークレット スキャン アラート修復後のコンソール出力を比較します。

これでアプリケーションの構造と動作を理解したので、GitHub Copilot を使用してセキュリティ アラートを分析する準備ができました。

### Copilot の質問モードを使用してシークレット スキャン アラートを分析する

GitHub Copilot の質問モードで提供されるインテリジェントなコード分析は、セキュリティの脆弱性、潜在的な影響、推奨される修復戦略を把握するのに役立ちます。 露出したシークレットを含むセキュリティの問題を体系的に分析すると、修正を実装する前に、問題について包括的な理解を深めることができます。

このタスクでは、GitHub Copilot の質問モードを使用して、コードベースのシークレット スキャン アラートを分析します。

そのためには、以下の手順を実行してください。

1. Visual Studio Code で GitHub Copilot チャットを開きます。

    チャット ビューを開くには、Visual Studio Code の左側にあるアクティビティ バーから [チャット] アイコンを選択するか、`Ctrl+Alt+I` (Windows/Linux) または `Cmd+Option+I` (Mac) キーを押します。

1. GitHub Copilot チャット ビューを開き、**質問**モードが選択されていること、**GPT-4.1** モデルが選択されていることを確認します。

    チャット ビューをまだ開いていない場合は、Visual Studio Code ウィンドウの上部にある **[チャット]** アイコンを選びます。

    > **注**:GitHub Copilot には、さまざまなチャット モデルが用意されています。 GPT-4.1 モデルは、優れたコード分析機能を提供するもので、GitHub Copilot Free プランに含まれています。 別のモデルを選択すると、得られる結果が異なる場合があります。

1. クリーンなチャット セッションから開始していることを確認します。

    以前にチャット ビューを使用していた場合は、新たに開始することをお勧めします。 **[新しいチャット]** ボタン (チャット パネルの上部にある **[+]** アイコン) を選択して、新しい会話を開始します。

#### データベース接続文字列の脆弱性を分析する

DatabaseService.cs ファイルにデータベース接続文字列の脆弱性が存在します。 このファイルを分析して、コード内に資格情報を格納することのセキュリティへの影響を理解します。

データベースの接続文字列の脆弱性を分析するには、次の手順に従います。

1. コード エディターで **Services/DatabaseService.cs** ファイルを開きます。

1. **ConnectionString** 定数 (9 行目) を見つけます。

1. コード エディターで、ConnectionString 定数を含む行全体を選択します。

    エディターでコードを選択すると、チャット コンテキストがフォーカスされます。 GitHub Copilot では、選択したコードを使用して、関連する分析と推奨事項が提供されます。

1. GitHub Copilot に、コードのセキュリティの脆弱性を分析するように依頼します。

    チャット入力ボックスに次のプロンプトを入力します。

    ```plaintext
    Analyze this connection string for security vulnerabilities. What are the risks of storing it this way?
    ```

1. GitHub Copilot の分析を確認します。

    GitHub Copilot は、データベース パスワードを含むハードコーディングされた資格情報が接続文字列に含まれていることを識別します。 分析では、次のようなリスクが説明される可能性があります。

    - リポジトリへのアクセス権を持つすべてのユーザーが、資格情報を見ることができる
    - 資格情報がバージョン管理履歴に表示される
    - コードを変更せずに資格情報をローテーションする方法がない
    - コンプライアンス違反 (PCI DSS、HIPAA など)
    - 未承認のデータベース アクセスの可能性

1. 特定の修復ガイダンスを要求します。

    チャット入力ボックスに次のプロンプトを入力します。

    ```plaintext
    What's the recommended way to store database connection strings securely in a .NET application?
    ```

1. 少し時間を取って、GitHub Copilot の修復提案を確認します。

    次のような推奨事項が表示されます。

    - 環境変数の使用
    - ローカル開発に .NET ユーザー シークレットを使用する
    - 運用環境で Azure Key Vault または AWS Secrets Manager を使用する
    - バージョン管理の対象から除外されている構成ファイルを使用する
    - 接続の詳細から資格情報を分離する接続文字列ビルダーを実装する

#### Stripe API キーの脆弱性を分析する

PaymentService.cs ファイルに Stripe API キーの脆弱性が存在します。 このファイルを分析して、支払い資格情報の露出によるセキュリティへの影響を理解します。

Stripe API キーの脆弱性を分析するには、次の手順に従います。

1. コード エディターで **Services/PaymentService.cs** ファイルを開きます。

1. **StripeApiKey** 定数 (8 行目) を見つけます。

1. コード エディターで、StripeApiKey 定数を含む行全体を選択します。

1. GitHub Copilot にセキュリティ リスクの分析を依頼します。

    チャット入力ボックスに次のプロンプトを入力します。

    ```plaintext
    Analyze this Stripe API key. What are the security risks of having it in the source code?
    ```

1. GitHub Copilot の分析を確認します。

    GitHub Copilot は、Stripe のライブ API キー (sk_live_*) が露出することは、次の理由から非常に危険であることを説明します。

    - 攻撃者が、承認されていない請求を行う可能性がある
    - 顧客の支払い情報にアクセスできる可能がある
    - 払い戻しを作成したり、トランザクションを変更したりできる可能性がある
    - キーは、制限なしの完全な API アクセスを提供する
    - Git 履歴に露出したら、キーを取り消す必要がある

1. Stripe API キーの具体的な修復ガイダンスを求めます。

    チャット入力ボックスに次のプロンプトを入力します。

    ```plaintext
    What's the best practice for storing API keys like Stripe in a C# application? How should I refactor this code to use environment variables?
    ```

1. GitHub Copilot の修復提案を確認します。

    次のような推奨事項が表示されます。

    - 環境変数を使用して API キーを格納する
    - `Environment.GetEnvironmentVariable()` を使用してキーを読み取る
    - 不足している環境変数を処理するための null チェックを追加する
    - ローカル開発に .NET ユーザー シークレットを使用する
    - 運用環境で Azure Key Vault または AWS Secrets Manager を使用する
    - ソース管理に実際の API キーをコミットしない

1. Stripe API キーの分析結果を文書化します。

    GitHub Copilot の推奨事項についてメモを取ります。 次のタスクでは、これらの特定の分析情報を使用して、エージェント モードでの修復をガイドします。

### Copilot のエージェント モードを使用してシークレット スキャン アラートを修復する

GitHub Copilot のエージェント モードは、ハードコーディングされたシークレットを安全な代替手段に置き換えるコード変更を提案することで、セキュリティの修正を実装するのに役立ちます。 エージェント モードは分析を行うだけにとどまらず、セキュリティのベスト プラクティスに従ったコード変更を積極的に提案して適用します。

このタスクでは、GitHub Copilot のエージェント モードを使用して、前のタスクで分析したシークレット スキャン アラートを修復します。 質問モードでの分析時に特定された修復戦略を適用します。 後で GitHub のプッシュ保護機能をテストするために、一部のシークレットは意図的に未修正のままにします。

そのためには、以下の手順を実行してください。

1. Visual Studio Code で GitHub Copilot チャット ビューが開かれていることを確認します。

1. **エージェント** モードに切り替えます。

    チャット パネルの上部にあるモード ドロップダウンを選択し、**[エージェント]** を選択します。 このモードを使用すると、Copilot はコード編集を直接提案して適用できます。

#### Stripe API キーの脆弱性を修復する

質問モードでの分析に基づいて、Stripe API キーを環境変数に移動する必要があることを確認しました。 次に、エージェント モードを使用してこの修正を実装します。

Stripe API キーの脆弱性を修復するには、次の手順に従います。

1. **Services/PaymentService.cs** ファイルがコード エディターで開かれていることを確認します。

1. GitHub Copilot に、分析から得た修復戦略を使用して Stripe API キーの問題を修正するように求めます。

    [チャット] 入力ボックスに、質問モードの結果を組み込んだ次のプロンプトを入力します。

    ```plaintext
    In the PaymentService class, replace the hard-coded Stripe API key with code that reads it from an environment variable called STRIPE_API_KEY. Add proper null checking and error handling.
    ```

    このプロンプトは、質問モードでの分析時に GitHub Copilot から推奨された修復アプローチを反映しています。

1. GitHub Copilot によって提案された変更を確認します。

    GitHub Copilot から次のような変更が提案されます。

    ```csharp
    - private const string StripeApiKey = "<hard-coded-stripe-api-key>";
    + private static readonly string? StripeApiKey = Environment.GetEnvironmentVariable("STRIPE_API_KEY");
    ```

    環境変数が設定されていないケースを処理するために、null チェック ロジックを追加することも GitHub Copilot で推奨される場合があります。 これは、質問モードでの分析で特定されたベスト プラクティスと一致します。

1. 変更を適用します。

    提案された変更が正しいと考えられ、分析から得た修復戦略と一致する場合は、**[保持]** または **[承諾]** を選択して PaymentService.cs ファイルに編集を適用します。 これで、ハードコーディングされたシークレットがソース コードから削除されました。

1. ファイルを保存します。

    `Ctrl+S` (Windows/Linux) または `Cmd+S` (Mac) キーを押して、変更を保存します。

#### データベース接続文字列の脆弱性を修復する

質問モードでの分析に基づいて、データベース接続文字列を環境変数または構成ファイルに移動する必要があることを確認しました。 次に、エージェント モードを使用してこの修正を実装します。

データベース接続文字列の脆弱性を修復するには、次の手順に従います。

1. コード エディターで **Services/DatabaseService.cs** ファイルを開きます。

1. GitHub Copilot に、分析から得た修復戦略を使用してデータベース接続文字列の問題を修正するように求めます。

    [チャット] 入力ボックスに、質問モードの結果を組み込んだ次のプロンプトを入力します。

    ```plaintext
    In the DatabaseService class, replace the hard-coded connection string with code that reads it from an environment variable called DB_CONNECTION_STRING. Add proper null checking and error handling.
    ```

    このプロンプトは、質問モードでの分析時に GitHub Copilot から推奨された修復アプローチを反映しています。

1. GitHub Copilot によって提案された変更を確認します。

    GitHub Copilot から、ハードコーディングされた接続文字列を削除して環境変数の参照に置き換える変更が提案されるはずです。 変更は次のようになります。

    ```csharp
    - private const string ConnectionString = "<hard-coded-connection-string>";
    + private static readonly string? ConnectionString = Environment.GetEnvironmentVariable("DB_CONNECTION_STRING");
    ```

    GitHub Copilot から null チェックとエラー処理も提案される可能性があります。 これは、質問モードでの分析で特定されたベスト プラクティスと一致します。

1. 変更を適用します。

    提案された変更が正しいと考えられ、分析から得た修復戦略と一致する場合は、**[保持]** または **[承諾]** を選択して DatabaseService.cs ファイルに編集を適用します。 これで、ハードコーディングされた資格情報がソース コードから削除されました。

1. ファイルを保存します。

#### 残りのシークレットは修正しない

このラボでは、残りのシークレット (SendGrid API キー、PayPal 資格情報、AWS 資格情報、Azure Storage キーなど) は修正しないまま残します。 これらを使用して、後のタスクで GitHub のプッシュ保護機能をテストします。

1. 少し時間を取って変更を確認します。

    シークレット スキャン アラートのうち、2 つ (Stripe と SendGrid の API キー) を修正しましたが、他のキーは意図的に修正しないままにしました。 こうすることで以下の操作が可能になります。

    - 修正をコミットしてプッシュし、解決したアラートが GitHub でどのように処理されるかを確認する
    - 後のタスクで残りのシークレットを使用してプッシュ保護をテストする

1. 次のタスクに進み、変更をコミットしてプッシュします。

### コミットと GitHub への変更のプッシュ

シークレット スキャン アラートの一部を修正した後、変更をコミットして GitHub にプッシュする必要があります。 これにより、修復されたコードに基づいて GitHub のセキュリティ アラートがどのように更新されるかを確認できます。

このタスクでは、コードの変更をコミットしてプッシュし、GitHub の [セキュリティ] タブで、修正したアラートが更新されていることを確認します。

そのためには、以下の手順を実行してください。

1. Visual Studio Code でソース管理ビューを開きます。

    左側のアクティビティ バーから [ソース管理] アイコンを選択するか、`Ctrl+Shift+G` (Windows/Linux) または `Cmd+Shift+G` (Mac) キーを押します。

1. 変更を確認します。

    **[変更]** の下に、変更されたファイル (Services/PaymentService.cs と Services/EmailService.cs) が表示されます。 これらは、ハードコーディングされたシークレットを削除したファイルです。

1. 変更をステージングします。

    変更された各ファイルの横にある **[+]** アイコンをクリックするか、**[変更]** セクションの上部にある **[+]** アイコンをクリックして、すべての変更をステージングします。

1. 説明メッセージを付けて変更をコミットします。

    [ソース管理] ビューの上部にあるメッセージ ボックスに、次のようなコミット メッセージを入力します。

    ```plaintext
    Remove hard-coded Stripe and SendGrid API keys
    ```

    次に、**[コミット]** ボタン (チェックマーク アイコン) をクリックするか、`Ctrl+Enter` (Windows/Linux) または `Cmd+Enter` (Mac) キーを押します。

1. Github に変更をプッシュします。

    [ソース管理] ビューの **[変更の同期]** ボタンまたは **[プッシュ]** オプションをクリックします。 コマンド ラインを使用している場合は、以下を実行できます。

    ```bash
    git push origin main
    ```

    > **注**:リポジトリに対してプッシュ保護が既に有効になっている場合は、シークレットを追加するのではなく、コードから削除しているためブロックされません。

1. プッシュが完了するまで待ちます。

    プッシュが成功すると、Visual Studio Code に通知が表示されます。

1. Web ブラウザーで GitHub のリポジトリに移動します。

1. [セキュリティ] タブを開きます。

    リポジトリ ページの上部にある **[セキュリティ]** タブをクリックします。

1. 左側のサイド バーから **[シークレット スキャン]** を選択します。

1. 更新されたアラートの状態を確認します。

    しばらくすると (GitHub の再スキャンにしばらくかかる場合があります)、次のことがわかります。

    - Stripe API キーのアラートが自動的にクローズされたか、解決済みとしてマークされています
    - SendGrid API キーのアラートが自動的にクローズされたか、解決済みとしてマークされています
    - その他のアラート (Azure SQL 接続文字列、PayPal 資格情報、AWS 資格情報など) はオープンのままです

    GitHub のシークレット スキャンでは、コードベースからシークレットが削除されると自動的に検出され、それに応じてアラートの状態が更新されます。

1. アラートがまだオープンと表示されている場合は、手動でクローズします。

    アラートをクリックし、解決策を確認して、**[以下としてクローズする]** > **[取り消し済み]** または **[修正済み]** を選択します。 シークレットがコードから削除されたことを説明するコメントを追加します。

### プッシュ保護を有効にしてテストする

GitHub のプッシュ保護機能により、シークレットが誤ってリポジトリにプッシュされるのを防ぐことができます。 有効にすると、既知のシークレット パターンを探してコミットがスキャンされ、シークレットが検出された場合はプッシュがブロックされ、リポジトリ履歴に入る前に削除する機会が提供されます。

このタスクでは、リポジトリに対してプッシュ保護を有効にし、ダミー シークレットを含むコミットをプッシュしてテストします。

そのためには、以下の手順を実行してください。

1. Web ブラウザーで GitHub のリポジトリに移動します。

1. リポジトリの設定を開きます。

    リポジトリ ページの上部にある **[設定]** タブをクリックします。

1. 左側のサイドバーから **[Code security and analysis] (コード セキュリティと分析)** を選択します。

1. **[プッシュ保護]** セクションを見つけます。

    下にスクロールして、[シークレット スキャン] セクションにあるプッシュ保護の設定を見つけます。

1. プッシュ保護を有効にする

    [プッシュ保護] の横にある **[有効にする]** ボタンをクリックします。 既に有効になっている場合は、この手順をスキップできます。

    > **注**:プッシュ保護は、パブリック リポジトリと、GitHub Advanced Security が有効になっているプライベート リポジトリで使用できます。

1. Visual Studio Code に戻ります。

1. コード エディターで **Services/EmailService.cs** ファイルを開きます。

1. **SendGridApiKey** 定数 (9 行目) を見つけます。

1. SendGrid API キーを変更して、プッシュ保護をテストします。

    既存の SendGrid API キーを別の値に変更して、新しいシークレットの追加をシミュレートします。

    これにより、開発者が誤ってコードに新しい API キーをコードにコミットすることをシミュレートします。 SendGrid キーは前のタスクで修復されていないため、これは残りの修正されていないシークレットの 1 つを表します。

1. ファイルを保存します。

1. 変更をステージングしてコミットします。

    ソース管理ビューで、EmailService.cs ファイルをステージングし、次のようなメッセージを付けてコミットします。

    ```plaintext
    Update SendGrid configuration
    ```

1. コミットのプッシュを試みます。

    **[変更の同期]** または **[プッシュ]** をクリックするか、コマンド ラインを使用します。

    ```bash
    git push origin main
    ```

1. プッシュ保護によるブロックを確認します。

    シークレットが検出されたことを示すエラー メッセージとともにプッシュが拒否されます。 エラー メッセージには、検出されたシークレット パターン (SendGrid API キー) が表示され、続行する方法が示されます。

    サンプルのエラー メッセージ:

    ```plaintext
    remote: error: GH013: Repository rule violations found for refs/heads/main.
    remote: 
    remote: - Push cannot contain secrets
    remote: 
    remote: Secret scanning found the following secrets:
    remote: 
    remote:   (SendGrid API Key) on line 9 of Services/EmailService.cs
    remote: 
    remote: To push your changes anyway, you can bypass this rule...
    ```

1. エラー メッセージを読んで理解します。

    このエラーは、プッシュ保護が正常に機能していることを確認するものです。 それによって、リポジトリへのシークレットの入力が防止されました。 これは、前のタスクで意図的に未修正にしたシークレットの 1 つであることに注意してください。

1. SendGrid API キーの変更を元に戻します。

    Services/EmailService.cs を開き、元の SendGrid API キー値を復元するか、変更を元に戻します。

1. ファイルを保存します。

1. コミットを修正して、変更したシークレットを削除します。

    ターミナルで  を実行します。

    ```bash
    git add Services/EmailService.cs
    git commit --amend --no-edit
    ```

    または、コミットを完全に破棄します。

    ```bash
    git reset --soft HEAD~1
    ```

1. 作業ディレクトリがクリーンであることを確認します。

    コードにダミー シークレットが残らないようにします。 [ソース管理] ビューに保留中の変更は表示されていない必要があります。

プッシュ保護により、リポジトリへのシークレットのプッシュが正常に防止されました。 実際のシナリオでは、この機能は、API キー、トークン、パスワード、その他の機密情報の誤ったコミットを、リポジトリ履歴の一部になる前にキャッチします。

## クリーンアップ

演習が完了したので、少し時間を取って、GitHub アカウントまたは GitHub Copilot サブスクリプションに保持したくない変更が加えられていないか確認します。 たとえば、ResolveGitHubSecurityAlerts リポジトリを削除することが必要になる可能性があります。 ラボ環境としてローカル PC を使用している場合は、この演習用に作成したリポジトリのローカル クローンをアーカイブするか、削除することができます。
